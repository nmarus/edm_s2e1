'use strict';

var htmlparser = require('htmlparser2');
var request = require('request');
var moment = require('moment');
var debug = require('debug')('sparkbot-token');

function base64encode(string) {
  return new Buffer(string).toString('base64');
}

function SparkBotToken(config) {
  
  if(!config.clientID || !config.clientSecret || !config.username || !config.password || !config.redirectURL ) {
    throw new Error('missing required config parameter');
  }
  
  this.clientID = config.clientID;
  this.clientSecret = config.clientSecret;
  
  this.username = config.username;
  this.password = config.password;
  
  this.redirectURL = config.redirectURL;
  this.redirectURLSafe = encodeURIComponent(config.redirectURL);
  
  this.authURL = 'https://idbroker.webex.com/idb/oauth2/v1/authorize';
  this.reqURL = 'https://idbroker.webex.com/idb/UI/Login';
  this.tokenURL = 'https://api.ciscospark.com/v1/access_token';
  
  this.scope = [ 
    'spark:memberships_read', 
    'spark:memberships_write', 
    'spark:people_read', 
    'spark:rooms_read', 
    'spark:rooms_write',
    'spark:messages_read',
    'spark:messages_write'
  ];
  this.scope = this.scope.join(' ');
  this.scopeURLSafe = encodeURIComponent(this.scope);
  
  this.expires;
  this.tokens;

}

SparkBotToken.prototype.get = function(callback) {

  var $this = this;
  
  // authenticate to spark and get security_code
  function requestSecurityCode(cb) {
    
    var goto = base64encode($this.authURL + '?response_type=code&client_id=' + $this.clientID + '&redirect_uri=' + $this.redirectURLSafe + '&scope=' + $this.scopeURLSafe);
    var sunQueryParamsString = base64encode('isCookie=false&fromGlobal=yes&realm=consumer&type=login&encodedParamsString=dHlwZT1sb2dpbg==&gotoUrl=' + goto + '&email=' + $this.username);
    
    var qs = { 
      IDToken0: '',
      IDToken1: $this.username,
      IDToken2: $this.password,
      IDButton: 'Sign In',
      goto: goto,
      SunQueryParamsString: sunQueryParamsString,
      encoded: 'true',
      loginid: $this.username,
      isAudioCaptcha: 'false',
      gx_charset: 'UTF-8'
    };
    
    request({url: $this.reqURL, qs: qs, jar: true, timeout: 5000}, function (err, response, body) {
      if (err) {
        cb(true, null);
      } else {
        var securityCode;
        // parse body for security_code
        var parser = new htmlparser.Parser({
          onopentag: function(name, attribs){
            if(attribs.name === 'security_code' && attribs.value){
              debug('security code: %s', attribs.value);
              securityCode = attribs.value;
              parser.done();
            }
          }
        }, {decodeEntities: true});
        parser.write(body);
        cb(null, securityCode);
      }
    });
  }
  
  // use security_code to get auth_code
  function requestAuthCode(securityCode, cb) {
    var formData = {
      security_code: securityCode,
      response_type: 'code',
      client_id: $this.clientID,
      decision: 'accept'
    };
    
    var qs = {
      response_type: 'code',
      client_id: $this.clientID,
      redirect_uri: $this.redirectURL,
      service: 'webex-squared',
      scope: $this.scope
    };
    
    request.post({url: $this.authURL, jar: true, qs: qs, form: formData}, function (err, response, body) {
      if (!err && response.statusCode == 302) {
        var code = response.headers.location.split('=');
        if (code[1]) {
          debug('auth code: %s', code[1]);
          cb(null, code[1]);
        } else {
          cb(true, null);
        }
      }
      else {
        cb(true, null);
      }
    });
  }
  
  // use auth_code to get tokens
  function requestToken(authCode, cb) {
    var formData = {
      grant_type:'authorization_code',
      client_id:$this.clientID,
      client_secret:$this.clientSecret,
      code: authCode,
      redirect_uri: $this.redirectURL
    };

    request.post({ url: $this.tokenURL, form: formData }, function(err, response, body) {
      if(err || !body || !JSON.parse(body)) {
        cb(err || new Error('invalid response'), null);
      } else {
        var tokens = JSON.parse(body);
        
        $this.tokens = tokens;
        $this.expires = moment().add($this.tokens.expires_in, 'seconds');
        debug('new token object: %j', $this.tokens);
        debug('expires: %s', $this.expires);
        cb(null, $this.tokens);
      }
    });
  }
  
  // refresh existing token
  function refreshToken(cb) {
    var formData = {
      grant_type: 'refresh_token',
      client_id: $this.clientID,
      client_secret: $this.clientSecret,
      refresh_token: $this.tokens ? $this.tokens.refresh_token : null
    };
  
    request.post({ url: $this.tokenURL, form:formData }, function (err, response, body) {
      if(err || !body || !JSON.parse(body)) {
        cb(err || new Error('invalid response'), null);
      } else {
        var refreshed = JSON.parse(body);
        
        $this.tokens.access_token = refreshed.access_token;
        $this.tokens.expires_in = refreshed.expires_in;
        $this.expires = moment().add($this.tokens.expires_in, 'seconds');
        debug('refreshed token object: %j', $this.tokens);
        debug('expires: %s', $this.expires);
        cb(null, $this.tokens);
      }
    });
  }
  
  // if tokens and not expired
  if($this.tokens && moment() < $this.expires) {
    debug('refreshing token...');
    refreshToken(function(err, tokens) {
      if(err) {
        throw new Error('error refreshing tokens');
      } else {
        callback(null, tokens);
      }
    });
  } else {
    debug('getting new token...');
    requestSecurityCode(function(err, securityCode) {
      if(err) {
        err = new Error('error requesting security code (1)');
        callback(err, null);
      } else {
        requestAuthCode(securityCode, function(err, authCode) {
          if(err) {
            err = new Error('error requesting auth code (2)');
            callback(err, null);
          } else {
            requestToken(authCode, function(err, tokens) {
              if(err) {
                err = new Error('error requesting tokens (3)');
                callback(err, null);
              } else {
                callback(null, tokens);
              }
            });
          }
        });
      }
    });
  }
  
};

module.exports = SparkBotToken;